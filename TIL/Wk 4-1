# Today I leared

## 25.02.23(Mon)-Day 14
-Lecture : 4. Algorhithms
           4) Bubble sort, 5) Selection sort, 6) Run-time of sort algorhitms
-Content : 버블 정렬에 대해
           선형 검색과 이진 검색은 정렬 여부에 따라 사용한다고 했다. 정렬 알고리즘 중 하나인 버블 정렬은 두 개의 인접한 값을 비교하여 위치를 바꾸는 방식의 정렬이다.
           6 3 5 8 2 7 4 1이 있을 때 버블 정렬을 통해 이를 오름차순으로 정렬하는 코드는 다음과 같다.
           Repeat n-1 times
           For i from 0 to n-2
              if i'th and i+1'th elements out of order
                 Swap them
           이 경우 바깥쪽 루프가 n-1, 안쪽 루프가 n-1이고 독립적으로 진행되기 때문에 버블 정렬의 상한은 O(n^2)라고 할 수 있다. 정렬 여부와 관계 없이 실행하므로 하한은 Ω(n^2)라고 할 수 있다.

           선택 정렬에 대해
           버블 정렬과는 다르게 선택 정렬은 배열 안의 모든 자료를 탐색하며 가장 작은 값(혹은 가장 큰 값)을 찾아 첫 번째 위치에 있는 수와 교환하는 방식의 정렬이다.
           6 3 5 8 2 7 4 1이 있을 때 선택 정렬을 통해 이를 오름차순으로 정렬하는 코드는 다음과 같다.
           For i from 0 to n-1
              Find smallest item between i'th item and last item
              Swap smallest item with i'th item
           이 경우 첫 루프에서는 n-1, 두 번째 루프에서는 n-2, 마지막 루프에서는 한 번 탐색이 진행되기 때문에 1부터 n-1까지의 합 공식을 쓴 결과 버블 정렬과 똑같이 상한은 O(n^2), 하한은 Ω(n^2)라고 할 수 있다.

           실행 시간에 대해
           여태까지의 검색 및 정렬의 실행 시간은 다음과 같다.
           O(n^2): 선택 정렬, 버블 정렬 / O(n): 선형 검색 / O(log n): 이진 검색 / Ω(n^2): 선택 정렬, 버블 정렬 / Ω(1): 선형 검색, 이진 검색
           이미 정렬되어 있는 경우 버블 정렬은 Repeat until no swaps로 수정을 통해 실행 시간의 하한을 Ω(n)로 바꿀 수 있지만 선택 정렬을 바꿀 수 없다. 
           다시 말해서 교환 횟수는 수정을 통해 줄일 수 있는데 탐색 횟수는 비슷한 방식으로 줄일 수 없다.

## 25.02.24(Tue)-Day 15
-Lecture : 4. Algorhithms
           7) Recursion, 8) Merge sort
-Content : 재귀에 대해
           함수가 본인 스스로를 호출해서 사용하는 것을 재귀라고 한다. 예를 들어 높이가 h인 피라미드를 만드는 코드를 작성해보면 다음과 같다.
           #include <cs50.h>
           #include <stdio.h>
           int main(void)
           {
              int height = get_int("Height: ");
              draw(height);
           }
           void draw(int h)
           {
              for (int i = 1; i <= h; i++)
              {
                 for (int j = 1; j <= h; j++)
                 {
                    printf("#");
                 }
                 printf(\n");
              }
           }
           여기서 재귀를 사용해서 draw 함수를 수정해보면 다음과 같다.
           #include <cs50.h>
           #include <stdio.h>
           int main(void)
           {
              int height = get_int("Height: ");
              draw(height);
           }
           void draw(int h)
           {
              if (h==0);
              {
                 return;
              }
              draw(h-1);
              for (int i = 1; i <= h; i++)
              {
                 printf("#");
              }
              printf("\n")
           }
           이러면 코드는 height를 3이라고 입력했을 때 draw(3) -> draw(2) -> draw(1) -> draw(0) -> return -> 폭이 1인 한 층 그리기 -> 폭이 2인 한 층 그리기 -> 폭이 3인 한 층 그리기 이 순서대로 작동한다.
           이렇게 함수 안에서 자신을 다시 호출하는 코드를 만났을 때 원래 하던 작업을 메모리에 일시정지 상태로 두고 새로운 함수로 진입하는 것을 콜 스택이라고 부른다.

           병합 정렬에 대해
           병합 정렬은 재귀적으로 구현되 정렬이다. 코드로 간단하게 나타내보면 다음과 같다.
           If only one item
              Return
           Else
              Sort left half of items
              Sort right half of items
              Merge them
           여기서 Merge, 즉 병합이란 두 배열 중 가장 작은 값을 꺼내 다른 배열의 가장 작은 값 다음에 두는 과정을 말한다. 
           이 코드를 설명하기 위한 예시로 7 4 5 2 6 3 8 1 이라는 배열이 주어졌을 때 7 4 5 2 / 6 3 8 1로 나누고 또 7 4 / 5 2 / 6 3 8 1로 나누고 또 7 / 4 / 5 2 / 6 3 8 1로 나눈다. 
           크기가 1이므로 각각 정렬되었으니 병합을 진행하면 4 7 / 5 2 / 6 3 8 1이 된다. 이제 4 7 / 5 / 2 / 6 3 8 1로 나눈다. 똑같이 크기가 1이므로 정렬되었으니 병합하면 4 7 / 2 5 / 6 3 8 1이 된다. 
           이제 이를 다시 병합하면 2 4 5 7 / 6 3 8 1이 된다. 이번엔 2 4 5 7 / 6 3 / 8 1 로 나누고 또 다시 2 4 5 7 / 6 / 3 / 8 1로 나누고 크기가 1이므로 정렬되었으니 병합을 하면 2 4 5 7 / 3 6 / 8 1이 된다.
           다시 2 4 5 7 / 3 6 / 8 / 1로 나누고 크기가 1이므로 정렬되었으니 병합하면 2 4 5 7 / 3 6 / 1 8이 된다. 이를 다시 병합하면 2 4 5 7 / 1 3 6 8이 되고 마지막으로 병합하면 1 2 3 4 5 6 7 8이 된다.
           병합 정렬의 상한과 하한은 모두 O(n log n), Ω(n log n)인데 강의 설명에서 층으로 나누어서 도식화한 것과 연산 횟수는 동일하기 때문에 그렇게 이해해도 된다. n을 곱하는 이유는 모든 병합마다 n개의 숫자를 모두 비교해야하기 때문이다.

## 25.02.25(Wed)-Day 16
-Lecture : 5. Memory
           1) Memory address, 2) Pointer, 3) String
-Content : 16진법에 대해
           10진수, 2진수 외에도 16진수가 존재한다. 이는 0123456789ABCDEF를 이용해서 나타내고 16진수임을 표현하기 위해 앞에 0x를 붙인다.

           메모리 주소에 대해
           #include <stdio.h>
           int main(void)
           {
              int n = 50;
              printf("%p\n", &n);
           }
           어떤 변수의 주소를 알고 싶을 때 위 코드처럼 변수를 지정하고 &라는 주소연산자와 %p라는 형식 지정자를 이용해 나타낸다. 
           여기서 주소연산자 앞에 *라는 포인트연산자를 붙이면 그 주소의 실제 값을 지정하는 것이고 그렇기때문에 %p 대신 %i를 사용해야한다.

           포인터에 대해
           #include <stdio.h>
           int main void
           {
              int n = 50;
              int *p = &n;
              printf("%p\n", p);
              printf("%i\n", *p);
           }
           위 코드처럼 int * 이라는 자료형을 통해 주소를 변수에 저장할 수 있다.

           문자열에 대해
           string s = “EMMA”;
           위의 코드처럼 지금까지 우리가 배웠던 string s = ~ 를 통해 변수를 지정하는 것은 사실 char *s = ~과 같다. 이전에 배웠던 typedef를 활용한 typedef char *string이 cs50 라이브러리에 있을 뿐이다.
           #include <cs50.h>
           #include <stdio.h>
           int main(void)
           {
               string s = "EMMA";
               printf("%s\n", s);
           }
           그런데 왜 위의 코드에서 1. EMMA가 아닌 주소가 저장되는 것이며, 2. 저장된 주소가 아닌 3. 그것도 E 하나가 아닌 EMMA 전체가 나오는 것일까?
           1. 컴퓨터가 ""(쌍따옴표)를 보는 순간 E, M, M, A, \0가 들어갈 5개의 방을 연속으로 만들어버리며 "EMMA" 라는 코드 자를 첫 번째 글자인 E가 저장된 메모리 주소로 바꿔버린다.
           2, 3. %p가 아닌 %s를 썼기 때문이다. %s는 '해당 주소로 가서 주소에 있는 글자를 출력한다. 그 다음 옆방으로 가서 그 글자를 출력하고 옆방 ->출력 과정을 널 종단 문자를 만날 때까지 반복한다'를 시키는 형식 지정자다.

## 25.02.26(Thu)-Day 17
-Lecture : 5. Memory
           4) String comparison, 5) String copy, 6) Memory allocation and free
-Content : 문자열에 대해
           #include <stdio.h>
           int main(void)
           {
              string s = "EMMA";
              printf("%p\n", s);
              printf("%p\n", &s[0]);
              printf("%c\n", *s);
           }
           위 코드를 실행하면 순서대로 E의 메모리 주소, E의 메모리 주소, E가 출력된다. s[0]은 *s와 같은 기능을 하는데 &를 만났기 때문에 상쇄된 거라고 이해할 수 있다.

           문자열 복사에 대해
           이처럼 우리가 그동안 변수를 지정하면서 썼던 자료형인 string은 char*였기 때문에 직관적인 예상과는 다른 결과가 발생할 수 있다.
           예를 들어, s와 t를 이용해 따로 문자열을 입력받고 string 자료형을 써서 지정했을 때 같은 문자열을 입력하더라도 메모리 주소가 다르기 때문에 컴퓨터는 다르다고 인식한다.
           s를 이용해서 문자열을 입력받고 string 자료형을 써서 지정한 후 할당 연산자를 이용해 string 자료형을 써서 t를 지정하면 메모리 주소가 같기 때문에 컴퓨터는 같다고 인식한다.
           그렇기 때문에 소문자의 문자열을 입력받고 그것과 대문자의 문자열을 순서대로 출력하는 코드는 다음과 같이 짜야한다.
           #include <stdio.h>
           #include <ctype.h>
           #include <string.h>
           #include <cs50.h>
           int main(void)
           {
              string s = get_string("s: ");
              string t = malloc(strlen(s)+1);
              for (int i = 0; n = strlen(s); i < n + 1; i++)
              {
                 t[i] = s[i];
              }
              t[0] = toupper(t[0]);
              printf("s: %s\n", s);
              printf("t: %s\n", t);
           }
           
           메모리 할당과 해제에 대해
           이전에 우리는 malloc을 통해 메모리 주소를 할당할 수 있다는 것을 알았는데 이렇게 할당한 후에는 free를 통해 우리가 임의로 할당한 메모리를 해제해야하고 그렇지 않는다면 메모리 누수가 발생한다.
           #include <stdio.h>
           void main(void)
           {
              int *x = malloc(10 * sizeof(int));
              x[10] = 0;
           }
           int main(void)
           {
              f();
              return 0;
           }
           위의 코드를 실행하면 두 가지 에러를 확인할 수 있다.(이러한 에러는 help50 valgrind ./filename처럼 valgrind를 이용한 코드를 실행하면 도움을 받을 수 있다)
           첫 번째는 버퍼 오버플로우로 버퍼란 데이터 임시 저장 공간인데 위 코드에서는 우리가 사용하라고 할당받은 정수를 담을 수 있는 10개짜리 메모리 공간이다. 
           이는 x[0]부터 x[9]인데 어디서 사용되고 있는지도 모르는 x[10]에 0을 덮어씌우라고 했기 때문에 문제가 된다.
           두 번째는 메모리 해제, 즉 free를 실행하지 않은 것으로 이 경우에는 메모리 누수가 발생한다. 이 두가지는 5번째 줄을 x[9]=0;로, 6번째 줄에 free(x)를 추가하면 해결된다.















