# Today I leared

## 25.02.23(Mon)-Day 14
-Lecture : 4. Algorhithms
           4) Bubble sort, 5) Selection sort, 6) Run-time of sort algorhitms
-Content : 버블 정렬에 대해
           선형 검색과 이진 검색은 정렬 여부에 따라 사용한다고 했다. 정렬 알고리즘 중 하나인 버블 정렬은 두 개의 인접한 값을 비교하여 위치를 바꾸는 방식의 정렬이다.
           6 3 5 8 2 7 4 1이 있을 때 버블 정렬을 통해 이를 오름차순으로 정렬하는 코드는 다음과 같다.
           Repeat n-1 times
           For i from 0 to n-2
              if i'th and i+1'th elements out of order
                 Swap them
           이 경우 바깥쪽 루프가 n-1, 안쪽 루프가 n-1이고 독립적으로 진행되기 때문에 버블 정렬의 상한은 O(n^2)라고 할 수 있다. 정렬 여부와 관계 없이 실행하므로 하한은 Ω(n^2)라고 할 수 있다.

           선택 정렬에 대해
           버블 정렬과는 다르게 선택 정렬은 배열 안의 모든 자료를 탐색하며 가장 작은 값(혹은 가장 큰 값)을 찾아 첫 번째 위치에 있는 수와 교환하는 방식의 정렬이다.
           6 3 5 8 2 7 4 1이 있을 때 선택 정렬을 통해 이를 오름차순으로 정렬하는 코드는 다음과 같다.
           For i from 0 to n-1
              Find smallest item between i'th item and last item
              Swap smallest item with i'th item
           이 경우 첫 루프에서는 n-1, 두 번째 루프에서는 n-2, 마지막 루프에서는 한 번 탐색이 진행되기 때문에 1부터 n-1까지의 합 공식을 쓴 결과 버블 정렬과 똑같이 상한은 O(n^2), 하한은 Ω(n^2)라고 할 수 있다.

           실행 시간에 대해
           여태까지의 검색 및 정렬의 실행 시간은 다음과 같다.
           O(n^2): 선택 정렬, 버블 정렬 / O(n): 선형 검색 / O(log n): 이진 검색 / Ω(n^2): 선택 정렬, 버블 정렬 / Ω(1): 선형 검색, 이진 검색
           이미 정렬되어 있는 경우 버블 정렬은 Repeat until no swaps로 수정을 통해 실행 시간의 하한을 Ω(n)로 바꿀 수 있지만 선택 정렬을 바꿀 수 없다. 
           다시 말해서 교환 횟수는 수정을 통해 줄일 수 있는데 탐색 횟수는 비슷한 방식으로 줄일 수 없다.

## 25.02.24(Tue)-Day 15
-Lecture : 4. Algorhithms
           7) Recursion, 8) Merge sort
-Content : 재귀에 대해
           함수가 본인 스스로를 호출해서 사용하는 것을 재귀라고 한다. 예를 들어 높이가 h인 피라미드를 만드는 코드를 작성해보면 다음과 같다.
           #include <cs50.h>
           #include <stdio.h>
           int main(void)
           {
              int height = get_int("Height: ");
              draw(height);
           }
           void draw(int h)
           {
              for (int i = 1; i <= h; i++)
              {
                 for (int j = 1; j <= h; j++)
                 {
                    printf("#");
                 }
                 printf(\n");
              }
           }
           여기서 재귀를 사용해서 draw 함수를 수정해보면 다음과 같다.
           #include <cs50.h>
           #include <stdio.h>
           int main(void)
           {
              int height = get_int("Height: ");
              draw(height);
           }
           void draw(int h)
           {
              if (h==0);
              {
                 return;
              }
              draw(h-1);
              for (int i = 1; i <= h; i++)
              {
                 printf("#");
              }
              printf("\n")
           }
           이러면 코드는 height를 3이라고 입력했을 때 draw(3) -> draw(2) -> draw(1) -> draw(0) -> return -> 폭이 1인 한 층 그리기 -> 폭이 2인 한 층 그리기 -> 폭이 3인 한 층 그리기 이 순서대로 작동한다.
           이렇게 함수 안에서 자신을 다시 호출하는 코드를 만났을 때 원래 하던 작업을 메모리에 일시정지 상태로 두고 새로운 함수로 진입하는 것을 콜 스택이라고 부른다.

           병합 정렬에 대해
           병합 정렬은 재귀적으로 구현되 정렬이다. 코드로 간단하게 나타내보면 다음과 같다.
           If only one item
              Return
           Else
              Sort left half of items
              Sort right half of items
              Merge them
           여기서 Merge, 즉 병합이란 두 배열 중 가장 작은 값을 꺼내 다른 배열의 가장 작은 값 다음에 두는 과정을 말한다. 
           이 코드를 설명하기 위한 예시로 7 4 5 2 6 3 8 1 이라는 배열이 주어졌을 때 7 4 5 2 / 6 3 8 1로 나누고 또 7 4 / 5 2 / 6 3 8 1로 나누고 또 7 / 4 / 5 2 / 6 3 8 1로 나눈다. 
           크기가 1이므로 각각 정렬되었으니 병합을 진행하면 4 7 / 5 2 / 6 3 8 1이 된다. 이제 4 7 / 5 / 2 / 6 3 8 1로 나눈다. 똑같이 크기가 1이므로 정렬되었으니 병합하면 4 7 / 2 5 / 6 3 8 1이 된다. 
           이제 이를 다시 병합하면 2 4 5 7 / 6 3 8 1이 된다. 이번엔 2 4 5 7 / 6 3 / 8 1 로 나누고 또 다시 2 4 5 7 / 6 / 3 / 8 1로 나누고 크기가 1이므로 정렬되었으니 병합을 하면 2 4 5 7 / 3 6 / 8 1이 된다.
           다시 2 4 5 7 / 3 6 / 8 / 1로 나누고 크기가 1이므로 정렬되었으니 병합하면 2 4 5 7 / 3 6 / 1 8이 된다. 이를 다시 병합하면 2 4 5 7 / 1 3 6 8이 되고 마지막으로 병합하면 1 2 3 4 5 6 7 8이 된다.
           병합 정렬의 상한과 하한은 모두 O(n log n), Ω(n log n)인데 강의 설명에서 층으로 나누어서 도식화한 것과 연산 횟수는 동일하기 때문에 그렇게 이해해도 된다. n을 곱하는 이유는 모든 병합마다 n개의 숫자를 모두 비교해야하기 때문이다.

-Lecture : 5. Memory
           1) , 2) 
-Content : 에 대해
           














