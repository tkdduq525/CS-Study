# Today I leared

## 25.02.23(Mon)-Day 14
-Lecture : 4. Algorhithms
           4) Bubble sort, 5) Selection sort, 6) Run-time of sort algorhitms
-Content : 버블 정렬에 대해
           선형 검색과 이진 검색은 정렬 여부에 따라 사용한다고 했다. 정렬 알고리즘 중 하나인 버블 정렬은 두 개의 인접한 값을 비교하여 위치를 바꾸는 방식의 정렬이다.
           6 3 5 8 2 7 4 1이 있을 때 버블 정렬을 통해 이를 오름차순으로 정렬하는 코드는 다음과 같다.
           Repeat n-1 times
           For i from 0 to n-2
              if i'th and i+1'th elements out of order
                 Swap them
           이 경우 바깥쪽 루프가 n-1, 안쪽 루프가 n-1이고 독립적으로 진행되기 때문에 버블 정렬의 상한은 O(n^2)라고 할 수 있다. 정렬 여부와 관계 없이 실행하므로 하한은 Ω(n^2)라고 할 수 있다.

           선택 정렬에 대해
           버블 정렬과는 다르게 선택 정렬은 배열 안의 모든 자료를 탐색하며 가장 작은 값(혹은 가장 큰 값)을 찾아 첫 번째 위치에 있는 수와 교환하는 방식의 정렬이다.
           6 3 5 8 2 7 4 1이 있을 때 선택 정렬을 통해 이를 오름차순으로 정렬하는 코드는 다음과 같다.
           For i from 0 to n-1
              Find smallest item between i'th item and last item
              Swap smallest item with i'th item
           이 경우 첫 루프에서는 n-1, 두 번째 루프에서는 n-2, 마지막 루프에서는 한 번 탐색이 진행되기 때문에 1부터 n-1까지의 합 공식을 쓴 결과 버블 정렬과 똑같이 상한은 O(n^2), 하한은 Ω(n^2)라고 할 수 있다.

           실행 시간에 대해
           여태까지의 검색 및 정렬의 실행 시간은 다음과 같다.
           O(n^2): 선택 정렬, 버블 정렬 / O(n): 선형 검색 / O(log n): 이진 검색 / Ω(n^2): 선택 정렬, 버블 정렬 / Ω(1): 선형 검색, 이진 검색
           이미 정렬되어 있는 경우 버블 정렬은 Repeat until no swaps로 수정을 통해 실행 시간의 하한을 Ω(n)로 바꿀 수 있지만 선택 정렬을 바꿀 수 없다. 
           다시 말해서 교환 횟수는 수정을 통해 줄일 수 있는데 탐색 횟수는 비슷한 방식으로 줄일 수 없다.

## 25.02.24(Tue)-Day 15
-Lecture : 4. Algorhithms
           7) Recursion, 8) Merge sort
-Content : 재귀에 대해
           함수가 본인 스스로를 호출해서 사용하는 것을 재귀라고 한다. 예를 들어 높이가 h인 피라미드를 만드는 코드를 작성해보면 다음과 같다.
           #include <cs50.h>
           #include <stdio.h>
           int main(void)
           {
              int height = get_int("Height: ");
              draw(height);
           }
           void draw(int h)
           {
              for (int i = 1; i <= h; i++)
              {
                 for (int j = 1; j <= h; j++)
                 {
                    printf("#");
                 }
                 printf(\n");
              }
           }
           여기서 재귀를 사용해서 draw 함수를 수정해보면 다음과 같다.
           #include <cs50.h>
           #include <stdio.h>
           int main(void)
           {
              int height = get_int("Height: ");
              draw(height);
           }
           void draw(int h)
           {
              if (h==0);
              {
                 return;
              }
              draw(h-1);
              for (int i = 1; i <= h; i++)
              {
                 printf("#");
              }
              printf("\n")
           }
           이러면 코드는 height를 3이라고 입력했을 때 draw(3) -> draw(2) -> draw(1) -> draw(0) -> return -> 폭이 1인 한 층 그리기 -> 폭이 2인 한 층 그리기 -> 폭이 3인 한 층 그리기 이 순서대로 작동한다.
           이렇게 함수 안에서 자신을 다시 호출하는 코드를 만났을 때 원래 하던 작업을 메모리에 일시정지 상태로 두고 새로운 함수로 진입하는 것을 콜 스택이라고 부른다.

           병합 정렬에 대해
           병합 정렬은 재귀적으로 구현되 정렬이다. 코드로 간단하게 나타내보면 다음과 같다.
           If only one item
              Return
           Else
              Sort left half of items
              Sort right half of items
              Merge them
           여기서 Merge, 즉 병합이란 두 배열 중 가장 작은 값을 꺼내 다른 배열의 가장 작은 값 다음에 두는 과정을 말한다. 
           이 코드를 설명하기 위한 예시로 7 4 5 2 6 3 8 1 이라는 배열이 주어졌을 때 7 4 5 2 / 6 3 8 1로 나누고 또 7 4 / 5 2 / 6 3 8 1로 나누고 또 7 / 4 / 5 2 / 6 3 8 1로 나눈다. 
           크기가 1이므로 각각 정렬되었으니 병합을 진행하면 4 7 / 5 2 / 6 3 8 1이 된다. 이제 4 7 / 5 / 2 / 6 3 8 1로 나눈다. 똑같이 크기가 1이므로 정렬되었으니 병합하면 4 7 / 2 5 / 6 3 8 1이 된다. 
           이제 이를 다시 병합하면 2 4 5 7 / 6 3 8 1이 된다. 이번엔 2 4 5 7 / 6 3 / 8 1 로 나누고 또 다시 2 4 5 7 / 6 / 3 / 8 1로 나누고 크기가 1이므로 정렬되었으니 병합을 하면 2 4 5 7 / 3 6 / 8 1이 된다.
           다시 2 4 5 7 / 3 6 / 8 / 1로 나누고 크기가 1이므로 정렬되었으니 병합하면 2 4 5 7 / 3 6 / 1 8이 된다. 이를 다시 병합하면 2 4 5 7 / 1 3 6 8이 되고 마지막으로 병합하면 1 2 3 4 5 6 7 8이 된다.
           병합 정렬의 상한과 하한은 모두 O(n log n), Ω(n log n)인데 강의 설명에서 층으로 나누어서 도식화한 것과 연산 횟수는 동일하기 때문에 그렇게 이해해도 된다. n을 곱하는 이유는 모든 병합마다 n개의 숫자를 모두 비교해야하기 때문이다.

-Lecture : 5. Memory
           1) Memory address, 2) Pointer, 3) String
-Content : 16진법에 대해
           10진수, 2진수 외에도 16진수가 존재한다. 이는 0123456789ABCDEF를 이용해서 나타내고 16진수임을 표현하기 위해 앞에 0x를 붙인다.

           메모리 주소에 대해
           #include <stdio.h>
           int main(void)
           {
              int n = 50;
              printf("%p\n", &n);
           }
           어떤 변수의 주소를 알고 싶을 때 위 코드처럼 변수를 지정하고 &라는 주소연산자와 %p라는 형식 지정자를 이용해 나타낸다. 
           여기서 주소연산자 앞에 *라는 포인트연산자를 붙이면 그 주소의 실제 값을 지정하는 것이고 그렇기때문에 %p 대신 %i를 사용해야한다.

           포인터에 대해
           #include <stdio.h>
           int main void
           {
              int n = 50;
              int *p = &n;
              printf("%p\n", p);
              printf("%i\n", *p);
           }
           위 코드처럼 int * 이라는 자료형을 통해 주소를 변수에 저장할 수 있다.

           문자열에 대해
           string s = “EMMA”;
           위의 코드처럼 지금까지 우리가 배웠던 string s = ~ 를 통해 변수를 지정하는 것은 사실 char *s = ~과 같다. 이전에 배웠던 typedef를 활용한 typedef char *string이 cs50 라이브러리에 있을 뿐이다.
           #include <cs50.h>
           #include <stdio.h>
           int main(void)
           {
               string s = "EMMA";
               printf("%s\n", s);
           }
           그런데 왜 위의 코드에서 1. EMMA가 아닌 주소가 저장되는 것이며, 2. 저장된 주소가 아닌 3. 그것도 E 하나가 아닌 EMMA 전체가 나오는 것일까?
           1. 컴퓨터가 ""(쌍따옴표)를 보는 순간 E, M, M, A, \0가 들어갈 5개의 방을 연속으로 만들어버리며 "EMMA" 라는 코드 자를 첫 번째 글자인 E가 저장된 메모리 주소로 바꿔버린다.
           2, 3. %p가 아닌 %s를 썼기 때문이다. %s는 '해당 주소로 가서 주소에 있는 글자를 출력한다. 그 다음 옆방으로 가서 그 글자를 출력하고 옆방 ->출력 과정을 널 종단 문자를 만날 때까지 반복한다'를 시키는 형식 지정자다.














